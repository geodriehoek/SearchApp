algemene topics/vragen:
    - heeft philippe voorkeur tussen:
        - extra logica om scheiding tussen getOne en getList te maken   <->    alles returned List, getOne is List.get(0)
    - algemene return-info overkoepelt alle repo-methoden?
        Momenteel: repo returnt Response OF void
            - service krijgt response, zet om naar usable data dmv helperKlasse
                -> repo catcht client.exceptions | helper catcht Jackson.exceptions
                    -> beter om service te laten catchen?? via aspect?
    - veel kleine object-klassen gemaakt: pagination: 2; searchform: 3
        -> goede oplossing?
            -> geneste klassen beter?
                - paginationDirection nested Class van paginationObject
                - ratingOptions, sortOptions nested Class van searchForm
                - PaginationDirection, nested Class van PaginationObject

    - validatie/security
        -> moet ik mij daarmee bezig houden?

BEZIG:   - placeholder-methods vervangen
            -> REST design afwerken

GEDAAN:
    - CRUD-afwerking
        - enkel PATCH (als single-field-updates) nog niet
    - REST api/swagger
    - refresh van resultList na details/delete.
        -> instance var van Controller nl. searchForm
        -> session attribute maken?? andere optie?
    - pagination
        -> search/from
        -> href -> getDIRECTIONPage() -> wijziging PaginationObject.direction -> redirect: resultList
    - alle Exceptions in repo door throwen tot Controller, zodat deze juist kan reageren
        -> repo wrapt specifiek -> service throwt overkoepelend -> controller kan nog steeds specifiek afhandelen
            => wat met afhandelen van overkoepelende SearchAppException op controller niveau?
        -> nadeel: alle methoden van repo tot service throwen -> noodzakelijk?
        -> catching in RestController
            -> hoe/welke info overbrengen?
    - FIX voor update/delete/index-latency
                -> async blijkt GEEN OPL
                -> index.refresh lijkt nog niet geintegreerd in RESTclient
                ===> "request.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);"
                    -> niet goed voor bulk
    FIX/OPTIMALISATIE:
    ------------------
        - verwijderen Product.id -> alles via grp_id: business-id == _id
            -> VRAAG PHILLIPE:
                - in reÃ«le gevallen, gebruikmaken van db-id? of business-id? => verschil tussen GET en SEARCH
                - na verwijderen van Product.id en voor herindexeren dataset:
                    => ObjectMapper exceptions omtrent fields niet aanwezig
                        -> waarom? geen probleem wanneer ik in Klasse extra velden toevoegde die niet in db staan
                                   wel als er in db meer velden staan dan in Klasse
                - welke HttpResponseCodes returnen? liever geen 500? of net wel
        - "If there is a version conflict, an ElasticsearchException will be thrown:
                         ----------------
           try {
               DeleteRequest request = new DeleteRequest("posts", "doc", "1").version(2);
               DeleteResponse deleteResponse = client.delete(request);
           } catch (ElasticsearchException exception) {
               if (exception.status() == RestStatus.CONFLICT) {

               }
           }"
            -> moet ik catchen??


TODO:   - exceptioncatching en logging optimaliseren
            -> algemene exceptions algemeen opvangen?
                -> bvb: RepositoryException
                    -> https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc#simplemappingexceptionresolver
                        of
                    -> https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc#using-controlleradvice-classes
                        -> enkel statische pagina's => return "repository-error.html";
            -> aspect voor logging? en Exception-info meesturen?
                -> aspect dat exception onderschept en bundelt in Object(returnUrl, status, message)
            -> REST
                -> https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc#errors-and-rest
        - validation : new-product.html
        - index from file?
        - suggesters (mapping van products-dataset ondersteunt dit nog niet)
            => mappings
        - ajax facets/suggestion
        (- search From/Size impl)
              => momenteel nog compleet onafhankelijk van limiet van results/ waar checken?
                   -> "A field with one unique value per document should be used as the tiebreaker of the sort specification.
                       Otherwise the sort order for documents that have the same sort values would be undefined.
                       The recommended way is to use the field _id which is certain to contain one unique value for each document."
                       https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-search-after.html
                   -> alternatief search_after (gelijkaardig aan scroll, doch stateless)


BUGS
----------
    - resultList -> details of one -> update this one -> return to resultList => placing of updated one changes
        -> only first change??

kleine vragen philippe
----------------------
    - RestAPI review
        - ProductController.delete() is @GetMapping, moet dit DELETE zijn, of enkel voor rest-api?
        - best practices rond enum-parameters van api-search: api/search/{string}/{customerRating}/...
    - pagination review
    - @ModelAttribute vragen aan philippe of goed als instance-var/ elders met queryparams
    - Thread.sleep() om NPE te vermijden
        -> Controller.update() -> update waarna refresh/ refresh te vroeg zodat ungeupdate entry getoond wordt
            -> mogelijkheid: asynchrone melding van save, waarna redirect?
    - client.close() forceren in ProductRepo
        -> vangt sowieso IOException op
        -> moet IllegalStateException (door .close()) dan ook opgevangen worden?
            -> stel realistisch scenario => hoe mee omgaan?
    - ExceptionConversionAspect werkt niet
        -> methode zelf moet nog steeds throws declareren in signature, methode die oproept moet nog altijd catchen voor compiler
            -> dus aspect onmogelijk? compeelt nutteloos?


VRAGEN THEORIE/PRACTICES VOOR PHILIPPE
--------------------------------------
    - exception handling
        -> waar? welke info? welke info is het belangrijkst
        -> o.a.: philippe liet eens vallen dat hij nooit aspects heeft gebruikt. waarom niet? mij leek aspects ideaal om structureel en consequent te catchen
    - testing
        -> beiden vnl theoretisch/conceptueel interessant aangezien praktischeid relatief simpel is??
    - git??
        -> gewoontes/voorkeuren binnen formica?
    - validatie/security
        -> moet ik mij daarmee bezig houden?
        -> niveau? zelf schrijven <-> impl
    - logging
        -> waar, welke info?
        -> dev vs. prod
    - returnen van data bestaande uit meerdere dataTypes?
        -> Klasse maken enige optie?
        -> tuples?
    - nut van stand-alone appilcations in huidige tijd?
        -> gezien ik de toepassing hiervan mogelijk heb overschat in mijn zelfstudie ivm web-applications





FIXES:
    - Elasticsearch exception [type=cluster_block_exception, reason=blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];]
        PUT your_index_name/_settings
          {"index": {"blocks": {"read_only_allow_delete": "false"}}}